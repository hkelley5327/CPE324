// CPE 324 Template File for Part 2 of Lab 4
// Behavioral Model of Capacitance Tester
// Template assumes you are counting 50 Mhz clocks during
// the capacitor under tests discharge cycle in binary after 
// this converting this count to the number of of 0.01 uF cap
// discharge cycles in binary and then converting
// this binary value to BCD for display
// B. Earl Wells
// January 29, 2026

module lab4(input SIG,CLOCK_50,output [6:0] HEX7,HEX6,HEX5,HEX4);

   reg l_flg; // this is a flag that may be used in your behavioral
              // design to allow a count value to be latched and 
              // cleared when SIG=1
              
   reg [23:0] count;     // cap 0.01 uf discharge time count
   reg [15:0] bcdout;    // bcd representation of cap value count
   
   reg sig;                   // debounced version of SIG
   reg [7:0] sh_reg = 8'd255; // last 8 past SIG states
   
   initial
      begin
      l_flg=0;
      count=0;
      end


   // 50 Mhz is very fast compared to the rise and fall times
   // of the 555 output so a debounce section may be useful
   // be useful to stop miss readings -- this debounce 
   // sections requires SIG to be constant for at least two
   // consecutive 50 Mhz clock cycles before the debounced 
   // version of SIG (i.e. named sig) is allowed to transition 
   always @ (posedge CLOCK_50)
      begin
         sh_reg = {sh_reg[6:0],SIG}; // left shift in value of SIG
         // if debounced value of sig is 0 then change to 1 only
         // when the last eight values of SIG are 1
         if (sig==0)  
            begin
            sig = (& sh_reg); // AND all 8 past values of SIG
            end
         // if debounced value of sig is 1 then change to 0 only
         // when the last eight values of SIG are 0
         else
            begin
               sig = (| sh_reg); // OR all 8 past values of SIG
            end
      end
      
   // Enter your MODELLING CODE HERE in this main always section !!            
   // may want to use the bintohex task and the bintobcd function
   // on the rising edge of your main clock, CLOCK_50, 
   // Do the following using an always @ procedural statement:
   always @(posedge CLOCK_50)
   
      begin 
      // Count the number of 50 MHZ clocks in each 0.01 uF discharge time 
      // period which occurs when sig=0 
      if (!sig)
         begin

				if (count < 24'd34656534)
					begin
						count <= count + 1;
					end
           
				l_flg <= 1;
         end
         
      // On the first clock cycle that SIG=1 convert and latch the output
      // data taken during the time SIG=0, clear the binary cap value count
      // and initialize the 0.01 uf time counter to its midrange value
      else
         begin
            if (l_flg)  
						begin
						reg [23:0] cap_units;
						
						cap_units = count / 3466;
						
						if (cap_units > 24'd9999)
							cap_units = 24'd9999;
					
						bcdout <= bintobcd(cap_units[15:0]);
					
						bintohex (bcdout[15:12], HEX7);
						bintohex (bcdout[11:8], HEX6);
						bintohex (bcdout[7:4], HEX5);	
						bintohex (bcdout[3:0], HEX4);
									
						count = 0;
								 
						l_flg = 0;
              end
         end
      end 
   // binary to 7-seg hexadecimal output task
   task bintohex (input [3:0] bin_num, output [6:0] hex_num);
      case (bin_num)
         0  : hex_num <= 7'b1000000;
         1  : hex_num <= 7'b1111001;
         2  : hex_num <= 7'b0100100;
         3  : hex_num <= 7'b0110000;
         4  : hex_num <= 7'b0011001;
         5  : hex_num <= 7'b0010010;
         6  : hex_num <= 7'b0000010;
         7  : hex_num <= 7'b1111000;
         8  : hex_num <= 7'b0000000;
         9  : hex_num <= 7'b0011000;
         10 : hex_num <= 7'b0001000;
         11 : hex_num <= 7'b0000011;
         12 : hex_num <= 7'b1000110;
         13 : hex_num <= 7'b0100001;
         14 : hex_num <= 7'b0000110;
         15 : hex_num <= 7'b0001110;
    default : hex_num <= 7'bx;
      endcase
   endtask

   // This is a user-defined function that returns a 16-bit BCD 
   // value from a 14-bit unsigned binary value
   function [15:0] bintobcd;
      input [13:0] bin_num;
      reg [15:0] bcd_num=0;
      reg [13:0] residual;

      reg [3:0] i;
      for (i=0;i<=3;i=i+1)
         begin
            residual=bin_num/10;             
            bcd_num=bcd_num+((bin_num-residual*10)<<4*i);
            bin_num=residual;
         end
      bintobcd=bcd_num; 
   endfunction

endmodule

