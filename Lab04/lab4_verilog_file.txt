// CPE 324 Template File for Part 1 of Lab 4
// Mostly Structural Design of Capacitance Tester
// B. Earl Wells
// Note: all modules are in this one file. This file has
//       been named lab4.v which matches the name of the
//       top level module, lab4. The module bcd_counter
//       should be completed as part this lab by the student.
//       The design itself is structural at the top level.
//       The component modules themselves are implemented
//       in  various ways (i.e. behavioral,
//       dataflow or structural).

// lab4 (Part 1) top-level module
module lab4(input SIG,CLOCK_50,output[6:0] HEX7,HEX6,HEX5,HEX4);

   wire en_pulse,cnt_clr,ff_en;

   wire [15:0] cnt_out,ff_out; // 16bit counter out and D ff out

   // need to set the two parameters for this module in order
   // for it to generate the correct pulse rate
   //             ¯\_(ツ)_/¯ 	
   count_enabler  #(3466,12) C0(.reset(SIG_deb),.clk(CLOCK_50),.en_out(en_pulse));

   bcd_counter      C1(.clear(cnt_clr),.en(en_pulse),.clk(CLOCK_50),.o(cnt_out));

   d_ff_16_en       C2(.d(cnt_out),.en(ff_en),.clk(CLOCK_50),.q(ff_out));
	
   bcdtohex_driver  C3(.bcd_in(ff_out),.hex4(HEX4),.hex5(HEX5),.hex6(HEX6),.hex7(HEX7));
	
   debounce         C4(.sig_out(SIG_deb),.sig_in(SIG),.clk(CLOCK_50));
	
	d_ff             C5(.d(SIG_deb),.clk(CLOCK_50),.q(cnt_clr));

   one_shot         C6(.tr(SIG_deb),.clk(CLOCK_50),.o(ff_en));
	
endmodule


// positive pulse active high one-shot element 
//    when the tr input is high this module will produce a single
//    positive pulse and will not produce another pulse until
//    the tr input is low for at least one cycle
// Inputs:
//   tr  -- active high trigger input
//   clk -- global clock input
// Output:
//   o   -- pulse output
module one_shot (input tr,clk,output o);

   reg state;

   assign o = ~state & tr;
   always @(posedge clk)
      begin
         state = tr;
      end

endmodule

// counter enabling module
// when the reset input is low, this module generally produces an enabling
// pulse after each "full_count" number of system clock cycles has passed.
// The length of this positive going pulse is one system clock period. 
// when the reset input is high no count enabling pulse is generated.
// After the reset input goes from high to low the very first enabling
// pulse occurs after "full_count"/2 system clock pulse to allow the
// least significant bit of the counter to always round up.
// 
// The "buswidth" and "full_count" parameters can be specified when this
// module is instantiated. The "busswidth" parameter is a derived parameter
// that should be set equal to a value of ceil(log2(full_count))
module count_enabler(input reset,clk,output reg en_out);

   // default parameter values (probably not correct for this application)
   parameter full_count=3466,buswidth=12;

   reg [buswidth-1:0] count;

   always @ (posedge clk, posedge reset)
      begin       
         if (reset)
            begin 
               count = full_count/2; // 1/2 full half count value
               en_out = 1;
            end
         else
            if (count)
               begin
                  count = count - 1;
                  en_out = 0;
               end
            else
               begin
                  count = full_count; // full count value
                  en_out = 1;
               end
      end

endmodule


// Advances the 4 "digit" (16 bit) BCD Counter
// to the next value for each rising edge clock
// cycle when the en input is '1'
module bcd_counter(input clear,en,clk, output reg [15:0] o);

   reg [15:0] count;

   always @(posedge clk, posedge clear)
      begin
         if (clear)
            begin
               count = 0;
            end 
         else
            begin
               if (en)
					  begin
							if (count[3:0] == 4'd9)
								begin
									count[3:0] = 4'd0;
									if (count[7:4] == 4'd9)
										begin
										count[7:4] = 4'd0;
											if (count[11:8] == 4'd9)
												begin
													count[11:8] = 4'd0;
													if (count[15:12] == 4'd9)
														begin
															count[15:12] = 4'd0;
														end
													else
														begin
															count[15:12] = count[15:12] + 4'd1;
														end
												end
											else
												begin
													count[11:8] = count[11:8] +4'd1;
												end
										end
									else
										begin
											count[7:4] = count[7:4] + 4'd1;
										end
								end
							else
								begin
									count[3:0] = count[3:0] + 4'd1;
								end
					  end
            end
			o = count;
      end
endmodule


// A continuously enabled D Flip-flop
module d_ff(input d,clk, output reg q);

   always @ (posedge clk)
      begin 
         q = d;
      end   

endmodule

// A continuously enabled JK Flip-flop
// data flow representation using characteristic equation
// (for use in structural model of debounce module)
module jk_ff(input j,k,clk, output reg q);

   always @ (posedge clk)
      begin 
         q <= (j & ~q) | (~k & q);
      end   

endmodule

// simple 16 bit wide D-FF with synchronous enable
module d_ff_16_en(input [15:0] d, input en,clk, output reg [15:0] q);

   always @ (posedge clk) 
      if (en)
         begin 
            q=d;
         end
      else
         begin 
            q=q;
         end

 endmodule
 
// A continuously enabled 8 stage debounce/metastability filter
// entirely structural implementation
module debounce(output sig_out,input sig_in,clk);

   wire [7:0] q;
	wire ones;
	wire zeroes;
	
	// 8 bit shift reg
	d_ff d0(sig_in, clk, q[0]);
	d_ff d1(q[0], clk, q[1]);
	d_ff d2(q[1], clk, q[2]);
	d_ff d3(q[2], clk, q[3]);
	d_ff d4(q[3], clk, q[4]);
	d_ff d5(q[4], clk, q[5]);
	d_ff d6(q[5], clk, q[6]);
	d_ff d07(q[6], clk, q[7]);
	
	assign ones = &q;		// are all dffs 1?
	assign zeroes = ~|q;	// are all dffs 0?
	
   jk_ff out_ff(ones, zeroes, clk, sig_out);
	
endmodule

// structural model of bintohex_driver
// (16 BCD to 4 7-segment LED display elements) 
module bcdtohex_driver(input [15:0] bcd_in, output [6:0] hex4,hex5,hex6,hex7);
   bintohex C0(hex4,bcd_in[3:0]);  // output least 7-seg sig
   bintohex C1(hex5,bcd_in[7:4]);
   bintohex C2(hex6,bcd_in[11:8]);
   bintohex C3(hex7,bcd_in[15:12]); // output least 7-seg sig
endmodule

// behavioral model of 4 bit binary to 7-segment 
// LED hexadecimal display element
module bintohex (output  reg [6:0] hex_out, input [3:0] bin_in); 

   always @ (bin_in)
      begin
         case (bin_in)
           0  : hex_out = 7'b1000000;
           1  : hex_out = 7'b1111001;
           2  : hex_out = 7'b0100100;
           3  : hex_out = 7'b0110000;
           4  : hex_out = 7'b0011001;
           5  : hex_out = 7'b0010010;
           6  : hex_out = 7'b0000010;
           7  : hex_out = 7'b1111000;
           8  : hex_out = 7'b0000000;
           9  : hex_out = 7'b0011000;
           10 : hex_out = 7'b0001000;
           11 : hex_out = 7'b0000011;
           12 : hex_out = 7'b1000110;
           13 : hex_out = 7'b0100001;
           14 : hex_out = 7'b0000110;
           15 : hex_out = 7'b0001110;
        default : hex_out = 7'bx;
         endcase
		end

endmodule

